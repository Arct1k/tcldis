<html>
<head>
    <script src="/static/react-0.11.2.min.js"></script>
    <script src="/static/JSXTransformer-0.11.2.js"></script>
    <script src="/static/jquery-2.1.1.min.js"></script>
</head>
<body>
<div id="tcldis"></div>
<style>
* {
    box-sizing: border-box;
    font-size: 12px;
    line-height: 1.2;
}
body { margin: 0; padding: 0; }
#codearea, #stepsarea {
    box-shadow: 0 0 0 2px grey inset; padding: 4px;
}
#codearea {
    position: fixed;
    height: 100%;
    top: 0; bottom: 0;
    width: 20%;
    display: table;
}
#codearea > div {
    display: table-row;
    position: relative;
}
#codearea > div+div { height: 100%; }
#codearea > div > textarea {
    position: relative;
    height: 100%;
    width: 100%;
}
#stepsarea {
    position: fixed;
    height: 100%;
    top: 0; bottom: 0;
    width: 80%;
    right: 0;
    overflow-x: hidden;
    overflow-y: hidden;
    padding: 0;
}
#stepsarea > #mainsteps {
    display: table;
    height: 90%;
    margin: 0 auto 0 auto;
    border-spacing: 0 5px;
}
#stepsarea > #mainsteps > div {
    display: table-cell;
    box-shadow: 0 0 0 1px grey inset;
    padding: 4px;
    vertical-align: top;
}
#stepsarea > #mainsteps > div > pre {
    width: 250px;
    height: 100%;
    overflow-x: auto;
}
#stepsarea > #mainsteps > div.step-padding {
    padding-left: 0;
    padding-right: 0;
}
.step-padding > div {
    position: relative;
    width: 50px;
    height: 100%;
}
.step-padding > div > svg {
    /* Have to remove from layout flow otherwise collapsing height to 0
     * stubbornly refuses to work. Otherwise we'd merge with the rule above. */
    position: absolute;
    width: 100%;
    height: 100%;
}
#stepsarea > #ministeps {
    position: absolute;
    display: table;
    margin-left: 50%;
}
#stepsarea > #ministeps > div {
    display: table-cell;
}
#stepsarea > #ministeps > div > pre {
    box-shadow: 0 0 0 1px grey inset; padding: 2px;
    font-size: 5px;
    width: 80px;
    overflow-x: hidden;
    overflow-y: hidden;
}
#stepsarea > #ministeps > div > pre span {
    font-size: inherit;
}
/* Ideally only one rule, but can't figure out how to make ministeps
 * table-cell div shrink in height to same size as child pre */
#mainsteps > .selected-step, #ministeps > .selected-step > pre {
    background-color: lightblue;
}
</style>
<script type="text/jsx">
/** @jsx React.DOM */
'use strict';
var miniwidth = 80;
var padwidth = 50;
var linemult = 1.2;
var fontsize = 12 * linemult;

function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function jsonpost(url, data, cb) {
    var r = new XMLHttpRequest();
    r.open('POST', url, true);
    r.setRequestHeader('Content-type', 'application/json');
    r.onreadystatechange = (function () {
        if (r.readyState != 4) return;
        var err = r.status !== 200; // we don't have 304's in this app
        var data = err ? null : JSON.parse(r.responseText);
        cb(err, data);
    });
    r.send(JSON.stringify(data));
}

var CodeArea = React.createClass({
    getInitialState: function () {
        jsonpost('/api/default_code', '', (function (err, data) {
            this.setState({'code': data});
            setTimeout(this.onDecompileClick, 0);
        }).bind(this));
        return {'code': ''};
    },
    handleChange: function (e) {
        this.setState({'code': e.target.value});
    },
    onDecompileClick: function () {
        this.props.decompileCB(this.state.code);
    },
    render: function () {
        return (
            <div id='codearea'>
                <div><button onClick={this.onDecompileClick}>decompile</button></div>
                <div><textarea onChange={this.handleChange} value={this.state.code} /></div>
            </div>
        );
    }
});

var DecompileSteps = React.createClass({
    handleKeyDown: function (e) {
        var key = e.key || e.keyCode;
        var stepIdx = this.state.stepIdx;
        // 37 <-, 38 ^, 39 ->, 40 \/
        if (key === 37) { this.changeStepIdx(-1); }
        else if (key === 38) { this.showMiniSteps(true); }
        else if (key === 39) { this.changeStepIdx(1); }
        else if (key === 40) { this.showMiniSteps(false); }
        else { return true; }
        e.preventDefault();
        return false;
    },
    showMiniSteps: function (shouldShow) {
        this.setState({'miniStepsOnly': shouldShow});
    },
    changeStepIdx: function (idxChange) {
        var stepIdx = this.state.stepIdx + idxChange;
        if (!(stepIdx < 0 || stepIdx >= this.props.steps.length)) {
            this.setState({'stepIdx': stepIdx});
        }
    },
    componentDidMount: function () {
        document.addEventListener('keydown', (function (e) {
            // Is this an event that was fired on us?
            var target = e.target;
            if (target != document && target != document.body) {
                while (target.parentNode != document.body) {
                    target = target.parentNode;
                }
                if (target != this.getDOMNode()) { return; }
            }
            return this.handleKeyDown(e);
        }).bind(this));
    },
    componentWillReceiveProps: function (nextProps) {
        var stepIdx = nextProps.steps.length - 2;
        if (stepIdx < 0) { stepIdx = 0; }
        this.setState({'stepIdx': stepIdx});
    },
    getInitialState: function () {
        return {'stepIdx': 0, 'miniStepsOnly': false};
    },
    render: function () {
        var stepIdx = this.state.stepIdx;
        var steps = [];
        var ministeps = [];
        this.props.steps.map(function (step, si) {
            var stepslist = steps;
            var elt = (
                <div className={stepIdx === si ? 'selected-step' : ''} key={si}>
                    <pre>{step.map(function (bb) {
                        return (
                            <span>{bb.map(function (inst) {
                                return <span>{inst+'\n'}</span>;
                            })}</span>
                        );
                    })}</pre>
                </div>
            );
            ministeps.push(elt);
            if (si < stepIdx - 1 || si > stepIdx + 1) { return; }
            steps.push(elt);
        }, this);
        // Add blank divs at beginning and end
        if (steps.length === 2) {
            if (steps[1].props.key != stepIdx + 1) {
                steps.push(<div key={stepIdx + 1}><pre> </pre></div>);
            } else if (steps[0].props.key != stepIdx - 1) {
                steps.unshift(<div key={stepIdx - 1}><pre> </pre></div>);
            }
        }

        function linefromchange(change, steps) {
            var numlines, bbi, ii, step,
                c = change,
                ss = steps,
                si = c[0];

            numlines = 0;
            bbi = 0;
            ii = 0;
            step = ss[si];
            var starty1, starty2;
            while (true) {
                if (bbi === c[1][0] && ii === c[1][1][0]) {
                    starty1 = numlines;
                    if (c[1][1][0] === c[1][1][1]) {
                        starty2 = numlines;
                        break;
                    }
                }
                numlines++;
                numlines += step[bbi][ii].split('\n').length - 1;
                if (bbi === c[1][0] && ii === c[1][1][1] - 1) {
                    if (c[1][1][0] !== c[1][1][1]) {
                        starty2 = numlines;
                    } else {
                        starty1 = starty2 = numlines;
                    }
                    break;
                }
                if (ii < step[bbi].length - 1) { ii++; }
                else if (bbi < step.length - 1) { bbi++; ii = 0; }
                else { throw Error(); }
            }

            numlines = 0;
            bbi = 0;
            ii = 0;
            step = ss[si+1];
            var endy1, endy2;
            while (true) {
                if (bbi === c[2][0] && ii === c[2][1][0]) {
                    endy1 = numlines;
                    if (c[2][1][0] === c[2][1][1]) {
                        endy2 = numlines;
                        break;
                    }
                }
                numlines++;
                numlines += step[bbi][ii].split('\n').length - 1;
                if (bbi === c[2][0] && ii === c[2][1][1] - 1) {
                    if (c[2][1][0] !== c[2][1][1]) {
                        endy2 = numlines;
                    } else {
                        endy1 = endy2 = numlines;
                    }
                    break;
                }
                if (ii < step[bbi].length - 1) { ii++; }
                else if (bbi < step.length - 1) { bbi++; ii = 0; }
                else { throw Error(); }
            }

            starty1 *= fontsize;
            starty2 *= fontsize;
            endy1 *= fontsize;
            endy2 *= fontsize;
            return [
                <line x1='0' y1={starty1} x2={padwidth} y2={endy1} stroke='black'/>,
                <line x1='0' y1={starty2} x2={padwidth} y2={endy2} stroke='black'/>
            ];
        }

        // Add the step padding
        var lines1 = [], lines2 = [];
        var changes = this.props.changes.map(function (c) {
            var step = c[0];
            var lines;
            if (step === stepIdx - 1) {
                lines = lines1;
            } else if (step === stepIdx) {
                lines = lines2;
            } else {
                return;
            }
            lines.push(linefromchange(c, this.props.steps));
        }, this);
        steps.splice(1, 0, <div className="step-padding"><div><svg>
            {lines1}
        </svg></div></div>);
        steps.splice(3, 0, <div className="step-padding"><div><svg>
            {lines2}
        </svg></div></div>);
        // Fold up the main steps if we're not displaying them
        var mainstepsstyle = {'transition': 'height 0.5s, opacity 0.5s'};
        if (this.state.miniStepsOnly) {
            mainstepsstyle.height = '0';
            mainstepsstyle.opacity = '0';
        }
        // Put the selected ministep halfway along the bottom
        var halfway = -((stepIdx * miniwidth) + (miniwidth / 2));
        var ministepsstyle = {
            'transition': 'left 0.2s',
            'left': halfway + 'px'
        };
        return (
            <div id='stepsarea'>
                <div id='mainsteps' style={mainstepsstyle}>{steps}</div>
                <div id='ministeps' style={ministepsstyle}>{ministeps}</div>
            </div>
        );
    }
});

var TclDisUI = React.createClass({
    getInitialState: function () {
        return {'steps': [], 'changes': []};
    },
    getDecompileSteps: function (code) {
        jsonpost('/api/decompile_steps', code, (function (err, data) {
            this.setState(data);
        }).bind(this));
    },
    render: function () {
        return (
            <div>
                <CodeArea decompileCB={this.getDecompileSteps} />
                <DecompileSteps steps={this.state.steps} changes={this.state.changes} />
            </div>
        );
    }
});
React.renderComponent(
    <TclDisUI />,
    document.getElementById('tcldis')
);
</script>
</body>
</html>
